// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package policy

import (
	"github.com/pulumi/pulumi/sdk/go/pulumi"
)

// Creates a Password Policy.
// 
// This resource allows you to create and configure a Password Policy.
//
// > This content is derived from https://github.com/articulate/terraform-provider-okta/blob/master/website/docs/r/policy_password.html.markdown.
type Password struct {
	s *pulumi.ResourceState
}

// NewPassword registers a new resource with the given unique name, arguments, and options.
func NewPassword(ctx *pulumi.Context,
	name string, args *PasswordArgs, opts ...pulumi.ResourceOpt) (*Password, error) {
	inputs := make(map[string]interface{})
	if args == nil {
		inputs["authProvider"] = nil
		inputs["description"] = nil
		inputs["emailRecovery"] = nil
		inputs["groupsIncludeds"] = nil
		inputs["name"] = nil
		inputs["passwordAutoUnlockMinutes"] = nil
		inputs["passwordDictionaryLookup"] = nil
		inputs["passwordExcludeFirstName"] = nil
		inputs["passwordExcludeLastName"] = nil
		inputs["passwordExcludeUsername"] = nil
		inputs["passwordExpireWarnDays"] = nil
		inputs["passwordHistoryCount"] = nil
		inputs["passwordMaxAgeDays"] = nil
		inputs["passwordMaxLockoutAttempts"] = nil
		inputs["passwordMinAgeMinutes"] = nil
		inputs["passwordMinLength"] = nil
		inputs["passwordMinLowercase"] = nil
		inputs["passwordMinNumber"] = nil
		inputs["passwordMinSymbol"] = nil
		inputs["passwordMinUppercase"] = nil
		inputs["passwordShowLockoutFailures"] = nil
		inputs["priority"] = nil
		inputs["questionMinLength"] = nil
		inputs["questionRecovery"] = nil
		inputs["recoveryEmailToken"] = nil
		inputs["skipUnlock"] = nil
		inputs["smsRecovery"] = nil
		inputs["status"] = nil
	} else {
		inputs["authProvider"] = args.AuthProvider
		inputs["description"] = args.Description
		inputs["emailRecovery"] = args.EmailRecovery
		inputs["groupsIncludeds"] = args.GroupsIncludeds
		inputs["name"] = args.Name
		inputs["passwordAutoUnlockMinutes"] = args.PasswordAutoUnlockMinutes
		inputs["passwordDictionaryLookup"] = args.PasswordDictionaryLookup
		inputs["passwordExcludeFirstName"] = args.PasswordExcludeFirstName
		inputs["passwordExcludeLastName"] = args.PasswordExcludeLastName
		inputs["passwordExcludeUsername"] = args.PasswordExcludeUsername
		inputs["passwordExpireWarnDays"] = args.PasswordExpireWarnDays
		inputs["passwordHistoryCount"] = args.PasswordHistoryCount
		inputs["passwordMaxAgeDays"] = args.PasswordMaxAgeDays
		inputs["passwordMaxLockoutAttempts"] = args.PasswordMaxLockoutAttempts
		inputs["passwordMinAgeMinutes"] = args.PasswordMinAgeMinutes
		inputs["passwordMinLength"] = args.PasswordMinLength
		inputs["passwordMinLowercase"] = args.PasswordMinLowercase
		inputs["passwordMinNumber"] = args.PasswordMinNumber
		inputs["passwordMinSymbol"] = args.PasswordMinSymbol
		inputs["passwordMinUppercase"] = args.PasswordMinUppercase
		inputs["passwordShowLockoutFailures"] = args.PasswordShowLockoutFailures
		inputs["priority"] = args.Priority
		inputs["questionMinLength"] = args.QuestionMinLength
		inputs["questionRecovery"] = args.QuestionRecovery
		inputs["recoveryEmailToken"] = args.RecoveryEmailToken
		inputs["skipUnlock"] = args.SkipUnlock
		inputs["smsRecovery"] = args.SmsRecovery
		inputs["status"] = args.Status
	}
	s, err := ctx.RegisterResource("okta:policy/password:Password", name, true, inputs, opts...)
	if err != nil {
		return nil, err
	}
	return &Password{s: s}, nil
}

// GetPassword gets an existing Password resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetPassword(ctx *pulumi.Context,
	name string, id pulumi.ID, state *PasswordState, opts ...pulumi.ResourceOpt) (*Password, error) {
	inputs := make(map[string]interface{})
	if state != nil {
		inputs["authProvider"] = state.AuthProvider
		inputs["description"] = state.Description
		inputs["emailRecovery"] = state.EmailRecovery
		inputs["groupsIncludeds"] = state.GroupsIncludeds
		inputs["name"] = state.Name
		inputs["passwordAutoUnlockMinutes"] = state.PasswordAutoUnlockMinutes
		inputs["passwordDictionaryLookup"] = state.PasswordDictionaryLookup
		inputs["passwordExcludeFirstName"] = state.PasswordExcludeFirstName
		inputs["passwordExcludeLastName"] = state.PasswordExcludeLastName
		inputs["passwordExcludeUsername"] = state.PasswordExcludeUsername
		inputs["passwordExpireWarnDays"] = state.PasswordExpireWarnDays
		inputs["passwordHistoryCount"] = state.PasswordHistoryCount
		inputs["passwordMaxAgeDays"] = state.PasswordMaxAgeDays
		inputs["passwordMaxLockoutAttempts"] = state.PasswordMaxLockoutAttempts
		inputs["passwordMinAgeMinutes"] = state.PasswordMinAgeMinutes
		inputs["passwordMinLength"] = state.PasswordMinLength
		inputs["passwordMinLowercase"] = state.PasswordMinLowercase
		inputs["passwordMinNumber"] = state.PasswordMinNumber
		inputs["passwordMinSymbol"] = state.PasswordMinSymbol
		inputs["passwordMinUppercase"] = state.PasswordMinUppercase
		inputs["passwordShowLockoutFailures"] = state.PasswordShowLockoutFailures
		inputs["priority"] = state.Priority
		inputs["questionMinLength"] = state.QuestionMinLength
		inputs["questionRecovery"] = state.QuestionRecovery
		inputs["recoveryEmailToken"] = state.RecoveryEmailToken
		inputs["skipUnlock"] = state.SkipUnlock
		inputs["smsRecovery"] = state.SmsRecovery
		inputs["status"] = state.Status
	}
	s, err := ctx.ReadResource("okta:policy/password:Password", name, id, inputs, opts...)
	if err != nil {
		return nil, err
	}
	return &Password{s: s}, nil
}

// URN is this resource's unique name assigned by Pulumi.
func (r *Password) URN() *pulumi.URNOutput {
	return r.s.URN()
}

// ID is this resource's unique identifier assigned by its provider.
func (r *Password) ID() *pulumi.IDOutput {
	return r.s.ID()
}

// Authentication Provider: `"OKTA"` or `"ACTIVE_DIRECTORY"`. Default is `"OKTA"`.
func (r *Password) AuthProvider() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["authProvider"])
}

// Policy Description.
func (r *Password) Description() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["description"])
}

// Enable or disable email password recovery: ACTIVE or INACTIVE.
func (r *Password) EmailRecovery() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["emailRecovery"])
}

// List of Group IDs to Include.
func (r *Password) GroupsIncludeds() *pulumi.ArrayOutput {
	return (*pulumi.ArrayOutput)(r.s.State["groupsIncludeds"])
}

// Policy Name.
func (r *Password) Name() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["name"])
}

// Number of minutes before a locked account is unlocked: 0 = no limit.
func (r *Password) PasswordAutoUnlockMinutes() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["passwordAutoUnlockMinutes"])
}

// Check Passwords Against Common Password Dictionary.
func (r *Password) PasswordDictionaryLookup() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["passwordDictionaryLookup"])
}

// User firstName attribute must be excluded from the password.
func (r *Password) PasswordExcludeFirstName() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["passwordExcludeFirstName"])
}

// User lastName attribute must be excluded from the password.
func (r *Password) PasswordExcludeLastName() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["passwordExcludeLastName"])
}

// If the user name must be excluded from the password.
func (r *Password) PasswordExcludeUsername() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["passwordExcludeUsername"])
}

// Length in days a user will be warned before password expiry: 0 = no warning.
func (r *Password) PasswordExpireWarnDays() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["passwordExpireWarnDays"])
}

// Number of distinct passwords that must be created before they can be reused: 0 = none.
func (r *Password) PasswordHistoryCount() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["passwordHistoryCount"])
}

// Length in days a password is valid before expiry: 0 = no limit.",
func (r *Password) PasswordMaxAgeDays() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["passwordMaxAgeDays"])
}

// Number of unsuccessful login attempts allowed before lockout: 0 = no limit.
func (r *Password) PasswordMaxLockoutAttempts() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["passwordMaxLockoutAttempts"])
}

// Minimum time interval in minutes between password changes: 0 = no limit.
func (r *Password) PasswordMinAgeMinutes() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["passwordMinAgeMinutes"])
}

// Minimum password length. Default is 8.
func (r *Password) PasswordMinLength() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["passwordMinLength"])
}

// Minimum number of lower case characters in password.
func (r *Password) PasswordMinLowercase() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["passwordMinLowercase"])
}

// Minimum number of numbers in password.
func (r *Password) PasswordMinNumber() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["passwordMinNumber"])
}

// Minimum number of symbols in password.
func (r *Password) PasswordMinSymbol() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["passwordMinSymbol"])
}

// Minimum number of upper case characters in password.
func (r *Password) PasswordMinUppercase() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["passwordMinUppercase"])
}

// If a user should be informed when their account is locked.
func (r *Password) PasswordShowLockoutFailures() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["passwordShowLockoutFailures"])
}

// Priority of the policy.
func (r *Password) Priority() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["priority"])
}

// Min length of the password recovery question answer.
func (r *Password) QuestionMinLength() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["questionMinLength"])
}

// Enable or disable security question password recovery: ACTIVE or INACTIVE.
func (r *Password) QuestionRecovery() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["questionRecovery"])
}

// Lifetime in minutes of the recovery email token.
func (r *Password) RecoveryEmailToken() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["recoveryEmailToken"])
}

// When an Active Directory user is locked out of Okta, the Okta unlock operation should also attempt to unlock the user's Windows account.
func (r *Password) SkipUnlock() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["skipUnlock"])
}

// Enable or disable SMS password recovery: ACTIVE or INACTIVE.
func (r *Password) SmsRecovery() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["smsRecovery"])
}

// Policy Status: `"ACTIVE"` or `"INACTIVE"`.
func (r *Password) Status() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["status"])
}

// Input properties used for looking up and filtering Password resources.
type PasswordState struct {
	// Authentication Provider: `"OKTA"` or `"ACTIVE_DIRECTORY"`. Default is `"OKTA"`.
	AuthProvider interface{}
	// Policy Description.
	Description interface{}
	// Enable or disable email password recovery: ACTIVE or INACTIVE.
	EmailRecovery interface{}
	// List of Group IDs to Include.
	GroupsIncludeds interface{}
	// Policy Name.
	Name interface{}
	// Number of minutes before a locked account is unlocked: 0 = no limit.
	PasswordAutoUnlockMinutes interface{}
	// Check Passwords Against Common Password Dictionary.
	PasswordDictionaryLookup interface{}
	// User firstName attribute must be excluded from the password.
	PasswordExcludeFirstName interface{}
	// User lastName attribute must be excluded from the password.
	PasswordExcludeLastName interface{}
	// If the user name must be excluded from the password.
	PasswordExcludeUsername interface{}
	// Length in days a user will be warned before password expiry: 0 = no warning.
	PasswordExpireWarnDays interface{}
	// Number of distinct passwords that must be created before they can be reused: 0 = none.
	PasswordHistoryCount interface{}
	// Length in days a password is valid before expiry: 0 = no limit.",
	PasswordMaxAgeDays interface{}
	// Number of unsuccessful login attempts allowed before lockout: 0 = no limit.
	PasswordMaxLockoutAttempts interface{}
	// Minimum time interval in minutes between password changes: 0 = no limit.
	PasswordMinAgeMinutes interface{}
	// Minimum password length. Default is 8.
	PasswordMinLength interface{}
	// Minimum number of lower case characters in password.
	PasswordMinLowercase interface{}
	// Minimum number of numbers in password.
	PasswordMinNumber interface{}
	// Minimum number of symbols in password.
	PasswordMinSymbol interface{}
	// Minimum number of upper case characters in password.
	PasswordMinUppercase interface{}
	// If a user should be informed when their account is locked.
	PasswordShowLockoutFailures interface{}
	// Priority of the policy.
	Priority interface{}
	// Min length of the password recovery question answer.
	QuestionMinLength interface{}
	// Enable or disable security question password recovery: ACTIVE or INACTIVE.
	QuestionRecovery interface{}
	// Lifetime in minutes of the recovery email token.
	RecoveryEmailToken interface{}
	// When an Active Directory user is locked out of Okta, the Okta unlock operation should also attempt to unlock the user's Windows account.
	SkipUnlock interface{}
	// Enable or disable SMS password recovery: ACTIVE or INACTIVE.
	SmsRecovery interface{}
	// Policy Status: `"ACTIVE"` or `"INACTIVE"`.
	Status interface{}
}

// The set of arguments for constructing a Password resource.
type PasswordArgs struct {
	// Authentication Provider: `"OKTA"` or `"ACTIVE_DIRECTORY"`. Default is `"OKTA"`.
	AuthProvider interface{}
	// Policy Description.
	Description interface{}
	// Enable or disable email password recovery: ACTIVE or INACTIVE.
	EmailRecovery interface{}
	// List of Group IDs to Include.
	GroupsIncludeds interface{}
	// Policy Name.
	Name interface{}
	// Number of minutes before a locked account is unlocked: 0 = no limit.
	PasswordAutoUnlockMinutes interface{}
	// Check Passwords Against Common Password Dictionary.
	PasswordDictionaryLookup interface{}
	// User firstName attribute must be excluded from the password.
	PasswordExcludeFirstName interface{}
	// User lastName attribute must be excluded from the password.
	PasswordExcludeLastName interface{}
	// If the user name must be excluded from the password.
	PasswordExcludeUsername interface{}
	// Length in days a user will be warned before password expiry: 0 = no warning.
	PasswordExpireWarnDays interface{}
	// Number of distinct passwords that must be created before they can be reused: 0 = none.
	PasswordHistoryCount interface{}
	// Length in days a password is valid before expiry: 0 = no limit.",
	PasswordMaxAgeDays interface{}
	// Number of unsuccessful login attempts allowed before lockout: 0 = no limit.
	PasswordMaxLockoutAttempts interface{}
	// Minimum time interval in minutes between password changes: 0 = no limit.
	PasswordMinAgeMinutes interface{}
	// Minimum password length. Default is 8.
	PasswordMinLength interface{}
	// Minimum number of lower case characters in password.
	PasswordMinLowercase interface{}
	// Minimum number of numbers in password.
	PasswordMinNumber interface{}
	// Minimum number of symbols in password.
	PasswordMinSymbol interface{}
	// Minimum number of upper case characters in password.
	PasswordMinUppercase interface{}
	// If a user should be informed when their account is locked.
	PasswordShowLockoutFailures interface{}
	// Priority of the policy.
	Priority interface{}
	// Min length of the password recovery question answer.
	QuestionMinLength interface{}
	// Enable or disable security question password recovery: ACTIVE or INACTIVE.
	QuestionRecovery interface{}
	// Lifetime in minutes of the recovery email token.
	RecoveryEmailToken interface{}
	// When an Active Directory user is locked out of Okta, the Okta unlock operation should also attempt to unlock the user's Windows account.
	SkipUnlock interface{}
	// Enable or disable SMS password recovery: ACTIVE or INACTIVE.
	SmsRecovery interface{}
	// Policy Status: `"ACTIVE"` or `"INACTIVE"`.
	Status interface{}
}
