// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package deprecated

import (
	"github.com/pulumi/pulumi/sdk/go/pulumi"
)

type PasswordPolicy struct {
	s *pulumi.ResourceState
}

// NewPasswordPolicy registers a new resource with the given unique name, arguments, and options.
func NewPasswordPolicy(ctx *pulumi.Context,
	name string, args *PasswordPolicyArgs, opts ...pulumi.ResourceOpt) (*PasswordPolicy, error) {
	inputs := make(map[string]interface{})
	if args == nil {
		inputs["authProvider"] = nil
		inputs["description"] = nil
		inputs["emailRecovery"] = nil
		inputs["groupsIncludeds"] = nil
		inputs["name"] = nil
		inputs["passwordAutoUnlockMinutes"] = nil
		inputs["passwordDictionaryLookup"] = nil
		inputs["passwordExcludeFirstName"] = nil
		inputs["passwordExcludeLastName"] = nil
		inputs["passwordExcludeUsername"] = nil
		inputs["passwordExpireWarnDays"] = nil
		inputs["passwordHistoryCount"] = nil
		inputs["passwordMaxAgeDays"] = nil
		inputs["passwordMaxLockoutAttempts"] = nil
		inputs["passwordMinAgeMinutes"] = nil
		inputs["passwordMinLength"] = nil
		inputs["passwordMinLowercase"] = nil
		inputs["passwordMinNumber"] = nil
		inputs["passwordMinSymbol"] = nil
		inputs["passwordMinUppercase"] = nil
		inputs["passwordShowLockoutFailures"] = nil
		inputs["priority"] = nil
		inputs["questionMinLength"] = nil
		inputs["questionRecovery"] = nil
		inputs["recoveryEmailToken"] = nil
		inputs["skipUnlock"] = nil
		inputs["smsRecovery"] = nil
		inputs["status"] = nil
	} else {
		inputs["authProvider"] = args.AuthProvider
		inputs["description"] = args.Description
		inputs["emailRecovery"] = args.EmailRecovery
		inputs["groupsIncludeds"] = args.GroupsIncludeds
		inputs["name"] = args.Name
		inputs["passwordAutoUnlockMinutes"] = args.PasswordAutoUnlockMinutes
		inputs["passwordDictionaryLookup"] = args.PasswordDictionaryLookup
		inputs["passwordExcludeFirstName"] = args.PasswordExcludeFirstName
		inputs["passwordExcludeLastName"] = args.PasswordExcludeLastName
		inputs["passwordExcludeUsername"] = args.PasswordExcludeUsername
		inputs["passwordExpireWarnDays"] = args.PasswordExpireWarnDays
		inputs["passwordHistoryCount"] = args.PasswordHistoryCount
		inputs["passwordMaxAgeDays"] = args.PasswordMaxAgeDays
		inputs["passwordMaxLockoutAttempts"] = args.PasswordMaxLockoutAttempts
		inputs["passwordMinAgeMinutes"] = args.PasswordMinAgeMinutes
		inputs["passwordMinLength"] = args.PasswordMinLength
		inputs["passwordMinLowercase"] = args.PasswordMinLowercase
		inputs["passwordMinNumber"] = args.PasswordMinNumber
		inputs["passwordMinSymbol"] = args.PasswordMinSymbol
		inputs["passwordMinUppercase"] = args.PasswordMinUppercase
		inputs["passwordShowLockoutFailures"] = args.PasswordShowLockoutFailures
		inputs["priority"] = args.Priority
		inputs["questionMinLength"] = args.QuestionMinLength
		inputs["questionRecovery"] = args.QuestionRecovery
		inputs["recoveryEmailToken"] = args.RecoveryEmailToken
		inputs["skipUnlock"] = args.SkipUnlock
		inputs["smsRecovery"] = args.SmsRecovery
		inputs["status"] = args.Status
	}
	s, err := ctx.RegisterResource("okta:deprecated/passwordPolicy:PasswordPolicy", name, true, inputs, opts...)
	if err != nil {
		return nil, err
	}
	return &PasswordPolicy{s: s}, nil
}

// GetPasswordPolicy gets an existing PasswordPolicy resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetPasswordPolicy(ctx *pulumi.Context,
	name string, id pulumi.ID, state *PasswordPolicyState, opts ...pulumi.ResourceOpt) (*PasswordPolicy, error) {
	inputs := make(map[string]interface{})
	if state != nil {
		inputs["authProvider"] = state.AuthProvider
		inputs["description"] = state.Description
		inputs["emailRecovery"] = state.EmailRecovery
		inputs["groupsIncludeds"] = state.GroupsIncludeds
		inputs["name"] = state.Name
		inputs["passwordAutoUnlockMinutes"] = state.PasswordAutoUnlockMinutes
		inputs["passwordDictionaryLookup"] = state.PasswordDictionaryLookup
		inputs["passwordExcludeFirstName"] = state.PasswordExcludeFirstName
		inputs["passwordExcludeLastName"] = state.PasswordExcludeLastName
		inputs["passwordExcludeUsername"] = state.PasswordExcludeUsername
		inputs["passwordExpireWarnDays"] = state.PasswordExpireWarnDays
		inputs["passwordHistoryCount"] = state.PasswordHistoryCount
		inputs["passwordMaxAgeDays"] = state.PasswordMaxAgeDays
		inputs["passwordMaxLockoutAttempts"] = state.PasswordMaxLockoutAttempts
		inputs["passwordMinAgeMinutes"] = state.PasswordMinAgeMinutes
		inputs["passwordMinLength"] = state.PasswordMinLength
		inputs["passwordMinLowercase"] = state.PasswordMinLowercase
		inputs["passwordMinNumber"] = state.PasswordMinNumber
		inputs["passwordMinSymbol"] = state.PasswordMinSymbol
		inputs["passwordMinUppercase"] = state.PasswordMinUppercase
		inputs["passwordShowLockoutFailures"] = state.PasswordShowLockoutFailures
		inputs["priority"] = state.Priority
		inputs["questionMinLength"] = state.QuestionMinLength
		inputs["questionRecovery"] = state.QuestionRecovery
		inputs["recoveryEmailToken"] = state.RecoveryEmailToken
		inputs["skipUnlock"] = state.SkipUnlock
		inputs["smsRecovery"] = state.SmsRecovery
		inputs["status"] = state.Status
	}
	s, err := ctx.ReadResource("okta:deprecated/passwordPolicy:PasswordPolicy", name, id, inputs, opts...)
	if err != nil {
		return nil, err
	}
	return &PasswordPolicy{s: s}, nil
}

// URN is this resource's unique name assigned by Pulumi.
func (r *PasswordPolicy) URN() *pulumi.URNOutput {
	return r.s.URN()
}

// ID is this resource's unique identifier assigned by its provider.
func (r *PasswordPolicy) ID() *pulumi.IDOutput {
	return r.s.ID()
}

// Authentication Provider: OKTA or ACTIVE_DIRECTORY.
func (r *PasswordPolicy) AuthProvider() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["authProvider"])
}

// Policy Description
func (r *PasswordPolicy) Description() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["description"])
}

// Enable or disable email password recovery: ACTIVE or INACTIVE.
func (r *PasswordPolicy) EmailRecovery() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["emailRecovery"])
}

// List of Group IDs to Include
func (r *PasswordPolicy) GroupsIncludeds() *pulumi.ArrayOutput {
	return (*pulumi.ArrayOutput)(r.s.State["groupsIncludeds"])
}

// Policy Name
func (r *PasswordPolicy) Name() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["name"])
}

// Number of minutes before a locked account is unlocked: 0 = no limit.
func (r *PasswordPolicy) PasswordAutoUnlockMinutes() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["passwordAutoUnlockMinutes"])
}

// Check Passwords Against Common Password Dictionary.
func (r *PasswordPolicy) PasswordDictionaryLookup() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["passwordDictionaryLookup"])
}

// User firstName attribute must be excluded from the password
func (r *PasswordPolicy) PasswordExcludeFirstName() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["passwordExcludeFirstName"])
}

// User lastName attribute must be excluded from the password
func (r *PasswordPolicy) PasswordExcludeLastName() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["passwordExcludeLastName"])
}

// If the user name must be excluded from the password.
func (r *PasswordPolicy) PasswordExcludeUsername() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["passwordExcludeUsername"])
}

// Length in days a user will be warned before password expiry: 0 = no warning.
func (r *PasswordPolicy) PasswordExpireWarnDays() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["passwordExpireWarnDays"])
}

// Number of distinct passwords that must be created before they can be reused: 0 = none.
func (r *PasswordPolicy) PasswordHistoryCount() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["passwordHistoryCount"])
}

// Length in days a password is valid before expiry: 0 = no limit.
func (r *PasswordPolicy) PasswordMaxAgeDays() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["passwordMaxAgeDays"])
}

// Number of unsuccessful login attempts allowed before lockout: 0 = no limit.
func (r *PasswordPolicy) PasswordMaxLockoutAttempts() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["passwordMaxLockoutAttempts"])
}

// Minimum time interval in minutes between password changes: 0 = no limit.
func (r *PasswordPolicy) PasswordMinAgeMinutes() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["passwordMinAgeMinutes"])
}

// Minimum password length.
func (r *PasswordPolicy) PasswordMinLength() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["passwordMinLength"])
}

// If a password must contain at least one lower case letter: 0 = no, 1 = yes. Default = 1
func (r *PasswordPolicy) PasswordMinLowercase() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["passwordMinLowercase"])
}

// If a password must contain at least one number: 0 = no, 1 = yes. Default = 1
func (r *PasswordPolicy) PasswordMinNumber() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["passwordMinNumber"])
}

// If a password must contain at least one symbol (!@#$%!^(MISSING)&*): 0 = no, 1 = yes. Default = 1
func (r *PasswordPolicy) PasswordMinSymbol() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["passwordMinSymbol"])
}

// If a password must contain at least one upper case letter: 0 = no, 1 = yes. Default = 1
func (r *PasswordPolicy) PasswordMinUppercase() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["passwordMinUppercase"])
}

// If a user should be informed when their account is locked.
func (r *PasswordPolicy) PasswordShowLockoutFailures() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["passwordShowLockoutFailures"])
}

// Policy Priority, this attribute can be set to a valid priority. To avoid endless diff situation we error if an invalid
// priority is provided. API defaults it to the last/lowest if not there.
func (r *PasswordPolicy) Priority() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["priority"])
}

// Min length of the password recovery question answer.
func (r *PasswordPolicy) QuestionMinLength() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["questionMinLength"])
}

// Enable or disable security question password recovery: ACTIVE or INACTIVE.
func (r *PasswordPolicy) QuestionRecovery() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["questionRecovery"])
}

// Lifetime in minutes of the recovery email token.
func (r *PasswordPolicy) RecoveryEmailToken() *pulumi.IntOutput {
	return (*pulumi.IntOutput)(r.s.State["recoveryEmailToken"])
}

// When an Active Directory user is locked out of Okta, the Okta unlock operation should also attempt to unlock the user's
// Windows account.
func (r *PasswordPolicy) SkipUnlock() *pulumi.BoolOutput {
	return (*pulumi.BoolOutput)(r.s.State["skipUnlock"])
}

// Enable or disable SMS password recovery: ACTIVE or INACTIVE.
func (r *PasswordPolicy) SmsRecovery() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["smsRecovery"])
}

// Policy Status: ACTIVE or INACTIVE.
func (r *PasswordPolicy) Status() *pulumi.StringOutput {
	return (*pulumi.StringOutput)(r.s.State["status"])
}

// Input properties used for looking up and filtering PasswordPolicy resources.
type PasswordPolicyState struct {
	// Authentication Provider: OKTA or ACTIVE_DIRECTORY.
	AuthProvider interface{}
	// Policy Description
	Description interface{}
	// Enable or disable email password recovery: ACTIVE or INACTIVE.
	EmailRecovery interface{}
	// List of Group IDs to Include
	GroupsIncludeds interface{}
	// Policy Name
	Name interface{}
	// Number of minutes before a locked account is unlocked: 0 = no limit.
	PasswordAutoUnlockMinutes interface{}
	// Check Passwords Against Common Password Dictionary.
	PasswordDictionaryLookup interface{}
	// User firstName attribute must be excluded from the password
	PasswordExcludeFirstName interface{}
	// User lastName attribute must be excluded from the password
	PasswordExcludeLastName interface{}
	// If the user name must be excluded from the password.
	PasswordExcludeUsername interface{}
	// Length in days a user will be warned before password expiry: 0 = no warning.
	PasswordExpireWarnDays interface{}
	// Number of distinct passwords that must be created before they can be reused: 0 = none.
	PasswordHistoryCount interface{}
	// Length in days a password is valid before expiry: 0 = no limit.
	PasswordMaxAgeDays interface{}
	// Number of unsuccessful login attempts allowed before lockout: 0 = no limit.
	PasswordMaxLockoutAttempts interface{}
	// Minimum time interval in minutes between password changes: 0 = no limit.
	PasswordMinAgeMinutes interface{}
	// Minimum password length.
	PasswordMinLength interface{}
	// If a password must contain at least one lower case letter: 0 = no, 1 = yes. Default = 1
	PasswordMinLowercase interface{}
	// If a password must contain at least one number: 0 = no, 1 = yes. Default = 1
	PasswordMinNumber interface{}
	// If a password must contain at least one symbol (!@#$%!^(MISSING)&*): 0 = no, 1 = yes. Default = 1
	PasswordMinSymbol interface{}
	// If a password must contain at least one upper case letter: 0 = no, 1 = yes. Default = 1
	PasswordMinUppercase interface{}
	// If a user should be informed when their account is locked.
	PasswordShowLockoutFailures interface{}
	// Policy Priority, this attribute can be set to a valid priority. To avoid endless diff situation we error if an invalid
	// priority is provided. API defaults it to the last/lowest if not there.
	Priority interface{}
	// Min length of the password recovery question answer.
	QuestionMinLength interface{}
	// Enable or disable security question password recovery: ACTIVE or INACTIVE.
	QuestionRecovery interface{}
	// Lifetime in minutes of the recovery email token.
	RecoveryEmailToken interface{}
	// When an Active Directory user is locked out of Okta, the Okta unlock operation should also attempt to unlock the user's
	// Windows account.
	SkipUnlock interface{}
	// Enable or disable SMS password recovery: ACTIVE or INACTIVE.
	SmsRecovery interface{}
	// Policy Status: ACTIVE or INACTIVE.
	Status interface{}
}

// The set of arguments for constructing a PasswordPolicy resource.
type PasswordPolicyArgs struct {
	// Authentication Provider: OKTA or ACTIVE_DIRECTORY.
	AuthProvider interface{}
	// Policy Description
	Description interface{}
	// Enable or disable email password recovery: ACTIVE or INACTIVE.
	EmailRecovery interface{}
	// List of Group IDs to Include
	GroupsIncludeds interface{}
	// Policy Name
	Name interface{}
	// Number of minutes before a locked account is unlocked: 0 = no limit.
	PasswordAutoUnlockMinutes interface{}
	// Check Passwords Against Common Password Dictionary.
	PasswordDictionaryLookup interface{}
	// User firstName attribute must be excluded from the password
	PasswordExcludeFirstName interface{}
	// User lastName attribute must be excluded from the password
	PasswordExcludeLastName interface{}
	// If the user name must be excluded from the password.
	PasswordExcludeUsername interface{}
	// Length in days a user will be warned before password expiry: 0 = no warning.
	PasswordExpireWarnDays interface{}
	// Number of distinct passwords that must be created before they can be reused: 0 = none.
	PasswordHistoryCount interface{}
	// Length in days a password is valid before expiry: 0 = no limit.
	PasswordMaxAgeDays interface{}
	// Number of unsuccessful login attempts allowed before lockout: 0 = no limit.
	PasswordMaxLockoutAttempts interface{}
	// Minimum time interval in minutes between password changes: 0 = no limit.
	PasswordMinAgeMinutes interface{}
	// Minimum password length.
	PasswordMinLength interface{}
	// If a password must contain at least one lower case letter: 0 = no, 1 = yes. Default = 1
	PasswordMinLowercase interface{}
	// If a password must contain at least one number: 0 = no, 1 = yes. Default = 1
	PasswordMinNumber interface{}
	// If a password must contain at least one symbol (!@#$%!^(MISSING)&*): 0 = no, 1 = yes. Default = 1
	PasswordMinSymbol interface{}
	// If a password must contain at least one upper case letter: 0 = no, 1 = yes. Default = 1
	PasswordMinUppercase interface{}
	// If a user should be informed when their account is locked.
	PasswordShowLockoutFailures interface{}
	// Policy Priority, this attribute can be set to a valid priority. To avoid endless diff situation we error if an invalid
	// priority is provided. API defaults it to the last/lowest if not there.
	Priority interface{}
	// Min length of the password recovery question answer.
	QuestionMinLength interface{}
	// Enable or disable security question password recovery: ACTIVE or INACTIVE.
	QuestionRecovery interface{}
	// Lifetime in minutes of the recovery email token.
	RecoveryEmailToken interface{}
	// When an Active Directory user is locked out of Okta, the Okta unlock operation should also attempt to unlock the user's
	// Windows account.
	SkipUnlock interface{}
	// Enable or disable SMS password recovery: ACTIVE or INACTIVE.
	SmsRecovery interface{}
	// Policy Status: ACTIVE or INACTIVE.
	Status interface{}
}
